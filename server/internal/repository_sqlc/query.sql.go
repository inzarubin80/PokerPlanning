// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc_repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPokerUser = `-- name: AddPokerUser :one
INSERT INTO poker_users (user_id, poker_id)
VALUES ($1, $2)
ON CONFLICT (user_id, poker_id)
DO UPDATE SET
    user_id = EXCLUDED.user_id,
    poker_id = EXCLUDED.poker_id
RETURNING user_id, poker_id
`

type AddPokerUserParams struct {
	UserID  int64
	PokerID pgtype.UUID
}

func (q *Queries) AddPokerUser(ctx context.Context, arg *AddPokerUserParams) (*PokerUser, error) {
	row := q.db.QueryRow(ctx, addPokerUser, arg.UserID, arg.PokerID)
	var i PokerUser
	err := row.Scan(&i.UserID, &i.PokerID)
	return &i, err
}

const addTask = `-- name: AddTask :one
INSERT INTO tasks (poker_id, title, description, story_point, status, completed, estimate)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING tasks_id, poker_id, title, description, story_point, status, completed, estimate
`

type AddTaskParams struct {
	PokerID     pgtype.UUID
	Title       string
	Description *string
	StoryPoint  *int32
	Status      string
	Completed   bool
	Estimate    *int32
}

func (q *Queries) AddTask(ctx context.Context, arg *AddTaskParams) (*Task, error) {
	row := q.db.QueryRow(ctx, addTask,
		arg.PokerID,
		arg.Title,
		arg.Description,
		arg.StoryPoint,
		arg.Status,
		arg.Completed,
		arg.Estimate,
	)
	var i Task
	err := row.Scan(
		&i.TasksID,
		&i.PokerID,
		&i.Title,
		&i.Description,
		&i.StoryPoint,
		&i.Status,
		&i.Completed,
		&i.Estimate,
	)
	return &i, err
}

const addUserAuthProviders = `-- name: AddUserAuthProviders :one
INSERT INTO user_auth_providers (user_id, provider_uid, provider, name)
VALUES ($1, $2, $3, $4)
returning user_id, provider_uid, provider, name
`

type AddUserAuthProvidersParams struct {
	UserID      int64
	ProviderUid string
	Provider    string
	Name        *string
}

func (q *Queries) AddUserAuthProviders(ctx context.Context, arg *AddUserAuthProvidersParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, addUserAuthProviders,
		arg.UserID,
		arg.ProviderUid,
		arg.Provider,
		arg.Name,
	)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const clearTasks = `-- name: ClearTasks :exec
DELETE FROM tasks WHERE poker_id = $1
`

func (q *Queries) ClearTasks(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearTasks, pokerID)
	return err
}

const createComent = `-- name: CreateComent :one
INSERT INTO comments (poker_id, user_id, task_id, text)
VALUES ($1, $2, $3, $4) 
RETURNING comment_id
`

type CreateComentParams struct {
	PokerID pgtype.UUID
	UserID  int64
	TaskID  int64
	Text    string
}

func (q *Queries) CreateComent(ctx context.Context, arg *CreateComentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createComent,
		arg.PokerID,
		arg.UserID,
		arg.TaskID,
		arg.Text,
	)
	var comment_id int64
	err := row.Scan(&comment_id)
	return comment_id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name)
VALUES ($1)
returning user_id
`

func (q *Queries) CreateUser(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, createUser, name)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE poker_id = $1 AND tasks_id = $2
`

type DeleteTaskParams struct {
	PokerID pgtype.UUID
	TasksID int64
}

func (q *Queries) DeleteTask(ctx context.Context, arg *DeleteTaskParams) error {
	_, err := q.db.Exec(ctx, deleteTask, arg.PokerID, arg.TasksID)
	return err
}

const getComments = `-- name: GetComments :many
SELECT comment_id, poker_id, user_id, task_id, text FROM comments
WHERE poker_id = $1 AND task_id = $2
`

type GetCommentsParams struct {
	PokerID pgtype.UUID
	TaskID  int64
}

func (q *Queries) GetComments(ctx context.Context, arg *GetCommentsParams) ([]*Comment, error) {
	rows, err := q.db.Query(ctx, getComments, arg.PokerID, arg.TaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.PokerID,
			&i.UserID,
			&i.TaskID,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT tasks_id, poker_id, title, description, story_point, status, completed, estimate FROM tasks WHERE poker_id = $1 AND tasks_id = $2
`

type GetTaskParams struct {
	PokerID pgtype.UUID
	TasksID int64
}

func (q *Queries) GetTask(ctx context.Context, arg *GetTaskParams) (*Task, error) {
	row := q.db.QueryRow(ctx, getTask, arg.PokerID, arg.TasksID)
	var i Task
	err := row.Scan(
		&i.TasksID,
		&i.PokerID,
		&i.Title,
		&i.Description,
		&i.StoryPoint,
		&i.Status,
		&i.Completed,
		&i.Estimate,
	)
	return &i, err
}

const getTasks = `-- name: GetTasks :many
SELECT tasks_id, poker_id, title, description, story_point, status, completed, estimate FROM tasks WHERE poker_id = $1 ORDER BY tasks_id
`

func (q *Queries) GetTasks(ctx context.Context, pokerID pgtype.UUID) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getTasks, pokerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TasksID,
			&i.PokerID,
			&i.Title,
			&i.Description,
			&i.StoryPoint,
			&i.Status,
			&i.Completed,
			&i.Estimate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthProvidersByProviderUid = `-- name: GetUserAuthProvidersByProviderUid :one
SELECT user_id, provider_uid, provider, name FROM user_auth_providers
WHERE provider_uid = $1 AND provider = $2
`

type GetUserAuthProvidersByProviderUidParams struct {
	ProviderUid string
	Provider    string
}

func (q *Queries) GetUserAuthProvidersByProviderUid(ctx context.Context, arg *GetUserAuthProvidersByProviderUidParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, getUserAuthProvidersByProviderUid, arg.ProviderUid, arg.Provider)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, name, evaluation_strategy, maximum_score FROM users
WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
	)
	return &i, err
}

const getUserIDsByPokerID = `-- name: GetUserIDsByPokerID :many
SELECT user_id, poker_id FROM poker_users
WHERE poker_id = $1
`

func (q *Queries) GetUserIDsByPokerID(ctx context.Context, pokerID pgtype.UUID) ([]*PokerUser, error) {
	rows, err := q.db.Query(ctx, getUserIDsByPokerID, pokerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PokerUser
	for rows.Next() {
		var i PokerUser
		if err := rows.Scan(&i.UserID, &i.PokerID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT user_id, name, evaluation_strategy, maximum_score FROM users
WHERE user_id = ANY($1::bigint[])
`

func (q *Queries) GetUsersByIDs(ctx context.Context, dollar_1 []int64) ([]*User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.EvaluationStrategy,
			&i.MaximumScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET
    title = $3,
    description = $4,
    story_point = $5,
    status = $6,
    completed = $7,
    estimate = $8
WHERE poker_id = $1 AND tasks_id = $2
RETURNING tasks_id, poker_id, title, description, story_point, status, completed, estimate
`

type UpdateTaskParams struct {
	PokerID     pgtype.UUID
	TasksID     int64
	Title       string
	Description *string
	StoryPoint  *int32
	Status      string
	Completed   bool
	Estimate    *int32
}

func (q *Queries) UpdateTask(ctx context.Context, arg *UpdateTaskParams) (*Task, error) {
	row := q.db.QueryRow(ctx, updateTask,
		arg.PokerID,
		arg.TasksID,
		arg.Title,
		arg.Description,
		arg.StoryPoint,
		arg.Status,
		arg.Completed,
		arg.Estimate,
	)
	var i Task
	err := row.Scan(
		&i.TasksID,
		&i.PokerID,
		&i.Title,
		&i.Description,
		&i.StoryPoint,
		&i.Status,
		&i.Completed,
		&i.Estimate,
	)
	return &i, err
}

const updateUserName = `-- name: UpdateUserName :one
UPDATE users
SET name = $1
WHERE user_id = $2
RETURNING user_id, name, evaluation_strategy, maximum_score
`

type UpdateUserNameParams struct {
	Name   string
	UserID int64
}

func (q *Queries) UpdateUserName(ctx context.Context, arg *UpdateUserNameParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserName, arg.Name, arg.UserID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
	)
	return &i, err
}

const upsertUserSettings = `-- name: UpsertUserSettings :one
INSERT INTO user_settings (user_id, evaluation_strategy, maximum_score)
VALUES ($1, $2, $3)
ON CONFLICT (user_id)
DO UPDATE SET
    user_id = EXCLUDED.user_id,
    evaluation_strategy = EXCLUDED.evaluation_strategy,
    maximum_score = EXCLUDED.maximum_score
RETURNING user_id, evaluation_strategy, maximum_score
`

type UpsertUserSettingsParams struct {
	UserID             int64
	EvaluationStrategy string
	MaximumScore       int32
}

func (q *Queries) UpsertUserSettings(ctx context.Context, arg *UpsertUserSettingsParams) (*UserSetting, error) {
	row := q.db.QueryRow(ctx, upsertUserSettings, arg.UserID, arg.EvaluationStrategy, arg.MaximumScore)
	var i UserSetting
	err := row.Scan(&i.UserID, &i.EvaluationStrategy, &i.MaximumScore)
	return &i, err
}
